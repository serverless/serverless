import fse from 'fs-extra'
import path from 'path'
import JSZip from 'jszip'
import { writeZip, addTree } from './zipTree.js'
import { sha256Path, getRequirementsLayerPath } from './shared.js'

/**
 * Zip up requirements to be used as layer package.
 * @return {Promise} the JSZip object constructed.
 */
async function zipRequirements() {
  const servicePath =
    this.servicePath ||
    this.serverless?.config?.servicePath ||
    this.serverless?.serviceDir ||
    process.cwd()
  const requirementsDir = path.join(servicePath, '.serverless')
  const src = path.join(requirementsDir, 'requirements')
  const requirementsTxtPath = path.join(requirementsDir, 'requirements.txt')
  const reqChecksum = sha256Path(requirementsTxtPath)
  const targetZipPath = path.join(requirementsDir, 'pythonRequirements.zip')
  const zipCachePath = getRequirementsLayerPath(
    reqChecksum,
    targetZipPath,
    this.options,
    this.serverless,
  )

  if (fse.existsSync(zipCachePath)) {
    let layerProgress
    if (this.progress && this.log) {
      layerProgress = this.progress.get('python-layer-requirements')
      layerProgress.update('Using cached Python Requirements Lambda Layer file')
      this.log.info('Found cached Python Requirements Lambda Layer file')
    } else {
      this.serverless.cli.log(
        'Found cached Python Requirements Lambda Layer file',
      )
    }
  } else {
    const rootZip = new JSZip()
    const runtimepath = 'python'
    const folder = rootZip.folder(runtimepath)
    await addTree(folder, src)
    await writeZip(rootZip, zipCachePath)
  }
  if (zipCachePath !== targetZipPath) {
    if (process.platform === 'win32') {
      fse.copySync(zipCachePath, targetZipPath)
    } else {
      fse.symlink(zipCachePath, targetZipPath, 'file')
    }
  }
}

/**
 * Creates a layer on the serverless service for the requirements zip.
 * @return {Promise} empty promise
 */
async function createLayers() {
  if (!this.serverless.service.layers) {
    this.serverless.service.layers = {}
  }
  this.serverless.service.layers['pythonRequirements'] = Object.assign(
    {
      artifact: path.join('.serverless', 'pythonRequirements.zip'),
      name: `${
        this.serverless.service.service
      }-${this.serverless.providers.aws.getStage()}-python-requirements`,
      description:
        'Python requirements generated by serverless-python-requirements.',
      compatibleRuntimes: [this.serverless.service.provider.runtime],
    },
    this.options.layer,
  )
  return
}

/**
 * Creates a layer from the installed requirements.
 * @return {Promise} the combined promise for requirements layer.
 */
async function layerRequirements() {
  if (!this.options.layer) return

  let layerProgress
  if (this.progress && this.log) {
    layerProgress = this.progress.get('python-layer-requirements')
    layerProgress.update('Packaging Python Requirements Lambda Layer')
    this.log.info('Packaging Python Requirements Lambda Layer')
  } else {
    this.serverless.cli.log('Packaging Python Requirements Lambda Layer...')
  }

  try {
    await zipRequirements.call(this)
    await createLayers.call(this)
  } finally {
    layerProgress && layerProgress.remove()
  }
}

export { layerRequirements }
