import {
  findOrCreateAutogeneratedDataset,
  getGeneratedDatasetName,
} from './dataset.js'
import { Axiom } from '@axiomhq/js'
import { createForwarder, getForwarderLambdaArn } from './forwarder.js'
import { getLambdaConfigsForFunctions, nonLambdaLogGroups } from './lambda.js'
import { isAnyFunctionIntegrated } from '../dashboard/index.js'
import { createOrUpdateSubscriber } from './subscriber.js'
import { createOrUpdateUnsubscriber } from './unsubscriber.js'
import { ServerlessError, ServerlessErrorCodes } from '@serverless/util'

/**
 * @typedef {Object} LambdaFunctionParam
 * @property {string} name - The name of the Lambda function.
 * @property {string} arch - The architecture type.
 * @property {string} cloudWatchLogGroupName - The CloudWatch log group name.
 */

/**
 * @typedef {Object} InitializeParams
 * @property {string} axiomToken - The Axiom API token.
 * @property {Object} awsCredentials - The AWS credentials.
 * @property {string} prefix - The prefix for the dataset name.
 * @property {string} region - The AWS region.
 * @property {string} [datasetName] - The name of the dataset.
 */

/**
 * @typedef {Object} InitializeResult
 * @property {Object} forwarder - The forwarder result.
 * @property {string} [forwarder.stackId] - The CloudFormation stack ID.
 * @property {string} forwarder.action - The action performed, either 'create' or 'update'.
 * @property {FindOrCreateDatasetResult} dataset - The dataset result.
 */

/**
 * @typedef {Object} ValidateParams
 * @property {string} dashboardAccessToken - The dashboard access token.
 * @property {string} awsAccountId - The AWS account ID.
 * @property {string} orgId - The organization ID.
 * @property {string} stage - The stage of the service.
 * @property {string} service - The name of the service.
 * @property {LambdaFunctionParam[]} [lambdaFunctions] - An array of Lambda function parameters.
 */

/**
 * @typedef {Object} ValidateResult
 * @property {string} axiomToken - The Axiom API token.
 */

/**
 * @typedef {Object} GetLambdaConfigsParams
 * @property {string} axiomToken - The Axiom API token.
 * @property {string} region - The AWS region.
 * @property {string} prefix - The prefix for the dataset name.
 * @property {string} [datasetName] - The name of the dataset.
 * @property {LambdaFunctionParam[]} [lambdaFunctions] - An array of Lambda function parameters.
 */

/**
 * @typedef {Object} LambdaAxiomConfig
 * @property {string} layerArn - The ARN of the Lambda layer.
 * @property {Object} environment - The environment variables for the Lambda function.
 * @property {string} environment.AXIOM_TOKEN - The Axiom token.
 * @property {string} environment.AXIOM_DATASET - The Axiom dataset name.
 */

/**
 * @typedef {Object} GetLambdaConfigsResult
 * @property {(LambdaAxiomConfig & LambdaFunctionParam)[]} lambdaConfigs - An array of Lambda configuration objects.
 */

/**
 * @typedef {Object} SubscribeLogGroupsParams
 * @property {Object} awsCredentials
 * @property {string} axiomToken - The Axiom API token.
 * @property {string} region - The AWS region.
 * @property {string} [datasetName] - The name of the dataset.
 * @property {string} prefix - The prefix for the dataset name.
 * @property {LambdaFunctionParam[]} [lambdaFunctions] - An array of Lambda function parameters.
 * @property {string[]} [resourcesLogGroupNames] - An array of CloudWatch Log Group names to be associated with the forwarder.
 */

/**
 * @typedef {Object} SubscribeLogGroupsResult
 * @property {Object} subscriber - The subscriber result.
 * @property {string} [subscriber.stackId] - The CloudFormation stack ID.
 * @property {string} subscriber.action - The action performed, either 'create' or 'update'.
 */

/**
 * @typedef {Object} UnsubscribeLogGroupsParams
 * @property {Object} awsCredentials
 * @property {string} region - The AWS region.
 * @property {string} prefix - The prefix for the dataset name.
 * @property {string} datasetName - The name of the dataset.
 * @property {LambdaFunctionParam[]} [lambdaFunctions] - An array of Lambda function parameters.
 * @property {string[]} [resourcesLogGroupNames] - An array of CloudWatch Log Group names to unsubscribe.
 */

/**
 * @typedef {Object} UnsubscribeLogGroupsResult
 * @property {Object} unsubscriber - The unsubscriber result.
 * @property {string} [unsubscriber.stackId] - The CloudFormation stack ID.
 * @property {string} unsubscriber.action - The action performed, either 'create' or 'update'.
 */

export const AXIOM_CLOUDFORMATION_STACKS_VERSION = '1.1.1'

/**
 * Retrieves the Axiom API token from the environment variables.
 *
 * @returns {string} - The Axiom API token.
 * @throws {Error} - Throws an error if the token is not found.
 */
function getToken() {
  const token = process.env.AXIOM_TOKEN
  if (!token) {
    const error = new ServerlessError(
      'No Axiom API Token found in environment variables. Please set "AXIOM_TOKEN". Sign up for Axiom here: https://slss.io/axiom',
      ServerlessErrorCodes.axiom.AXIOM_TOKEN_NOT_FOUND,
    )
    error.stack = undefined
    throw error
  }
  return token
}

/**
 * Validates and retrieves the Axiom API token.
 *
 * @param {ValidateParams} params - The validation parameters.
 * @returns {Promise<ValidateResult>} - The validation result containing the Axiom API token.
 * @throws {Error} - Throws an error if any Lambda function is already integrated with Dashboard.
 */
export const validateAndGetToken = async ({
  dashboardAccessToken,
  awsAccountId,
  orgId,
  stage,
  service,
  lambdaFunctions = [],
  frameworkVersion,
}) => {
  try {
    if (
      await isAnyFunctionIntegrated({
        dashboardAccessToken,
        lambdaFunctionNames: lambdaFunctions?.map((f) => f.name) ?? [],
        stage,
        service,
        awsAccountId,
        orgId,
        frameworkVersion,
      })
    ) {
      throw new ServerlessError(
        'At least one of the provided Lambda functions is already integrated with Dashboard.' +
          'If you want to integrate them with Axiom, please remove the integration from Dashboard first.',
        ServerlessErrorCodes.axiom.AXIOM_ALREADY_INTEGRATED_WITH_DASHBOARD,
      )
    }
  } catch (error) {
    if (error instanceof ServerlessError) {
      throw error
    }
    throw new ServerlessError(
      'Failed to check if any Lambda function is already integrated with Dashboard. Original error: ' +
        error.message,
      ServerlessErrorCodes.axiom.AXIOM_DASHBOARD_CHECK_FAILED,
    )
  }
  const axiomToken = getToken()
  return {
    axiomToken,
  }
}

/**
 * Initializes the Axiom forwarder and dataset.
 *
 * @param {InitializeParams} params - The initialization parameters.
 * @returns {Promise<InitializeResult>} - The initialization result containing the forwarder and dataset information.
 */
export const initialize = async ({
  axiomToken,
  awsCredentials,
  prefix,
  region,
  datasetName,
}) => {
  const client = new Axiom({ token: axiomToken })
  const dataset = await (async () => {
    try {
      return await findOrCreateAutogeneratedDataset({
        client,
        prefix,
        datasetName,
      })
    } catch (error) {
      if (error.message?.includes('forbidden')) {
        throw new ServerlessError(
          `Failed to initialize Axiom dataset. Check your Axiom API token permissions. Original Axiom error: ${error.message}`,
          ServerlessErrorCodes.axiom.AXIOM_INITIALIZE_DATASET_FAILED,
        )
      }
      if (!(error instanceof ServerlessError)) {
        throw new ServerlessError(
          `Failed to initialize Axiom dataset. Original Axiom error: ${error.message}`,
          ServerlessErrorCodes.axiom.AXIOM_INITIALIZE_DATASET_FAILED,
        )
      }
      throw error
    }
  })()
  const forwarder = await createForwarder({
    axiomToken,
    awsCredentials,
    region,
    datasetName: dataset.dataset.name,
  })
  return {
    forwarder: {
      stackId: forwarder?.StackId,
      action: 'create',
    },
    dataset,
  }
}

/**
 * Retrieves the Lambda configuration for the specified parameters.
 *
 * @param {GetLambdaConfigsParams} params - The parameters for getting the Lambda configurations.
 * @returns {Promise<GetLambdaConfigsResult>} - The Lambda configurations result.
 */
export const getLambdaConfigs = async ({
  axiomToken,
  region,
  prefix,
  datasetName = getGeneratedDatasetName(prefix),
  lambdaFunctions = [],
}) => {
  const lambdaConfigs = await getLambdaConfigsForFunctions(
    axiomToken,
    region,
    datasetName,
    lambdaFunctions,
  )
  return {
    lambdaConfigs,
  }
}

/**
 * Subscribes the specified log groups to the Axiom forwarder.
 *
 * @param {SubscribeLogGroupsParams} params - The parameters for subscribing log groups.
 * @returns {Promise<SubscribeLogGroupsResult>} - The result of the subscription operation.
 */
export const subscribeLogGroups = async ({
  axiomToken,
  awsCredentials,
  region,
  datasetName,
  prefix,
  lambdaFunctions = [],
  resourcesLogGroupNames = [],
}) => {
  const client = new Axiom({ token: axiomToken })
  const dataset = await findOrCreateAutogeneratedDataset({
    client,
    prefix,
    datasetName,
  })
  const cloudWatchLogGroupNames = nonLambdaLogGroups({
    lambdaFunctions,
    resourcesLogGroupNames,
  })
  const forwarderLambdaArn = await getForwarderLambdaArn({
    awsCredentials,
    region,
    datasetName: dataset.dataset.name,
  })
  if (!cloudWatchLogGroupNames || cloudWatchLogGroupNames.length === 0) {
    return
  }
  const subscriber = await createOrUpdateSubscriber({
    datasetName: dataset.dataset.name,
    awsCredentials,
    region,
    forwarderLambdaArn,
    cloudWatchLogGroupNames,
  })
  return {
    subscriber: {
      stackId: subscriber?.StackId,
      action: subscriber?.action,
    },
  }
}

/**
 * Unsubscribes the specified log groups from the Axiom forwarder.
 *
 * @param {UnsubscribeLogGroupsParams} params - The parameters for unsubscribing log groups.
 * @returns {Promise<UnsubscribeLogGroupsResult>} - The result of the unsubscription operation.
 * */
export const unsubscribeLogGroups = async ({
  awsCredentials,
  region,
  prefix,
  datasetName = getGeneratedDatasetName(prefix),
  lambdaFunctions = [],
  resourcesLogGroupNames = [],
}) => {
  const cloudWatchLogGroupNames = nonLambdaLogGroups({
    lambdaFunctions,
    resourcesLogGroupNames,
  })
  if (!cloudWatchLogGroupNames || cloudWatchLogGroupNames.length === 0) {
    return
  }
  try {
    getToken()
  } catch (e) {
    if (
      e instanceof ServerlessError &&
      e.code === ServerlessErrorCodes.axiom.AXIOM_TOKEN_NOT_FOUND
    ) {
      return
    }
  }
  const unsubscriber = await createOrUpdateUnsubscriber({
    datasetName,
    awsCredentials,
    region,
    cloudWatchLogGroupNames,
  })
  return {
    unsubscriber: {
      stackId: unsubscriber?.StackId,
      action: unsubscriber?.action,
    },
  }
}
